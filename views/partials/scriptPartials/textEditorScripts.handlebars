<script type="text/custom-template" id="new-post-link-preview-contents">
    <img class="link-preview-image" src="/images/spinner-stolen.gif" />
    <div class="link-preview-text-container" style="width:100%;">
        <span class="link-preview-title">...loading...</span>
        <span class="link-preview-description">...loading...</span>
        <span class="link-preview-domain">...loading...</span>
    </div>
    <div class="image-preview-controls">
        <div class="image-control image-clear" title="Clear"><i class="fas fa-times"></i></div>
        <div class="image-control image-move" title="Move" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></div>
    </div>
</script>

<script type="text/custom-template" id="new-post-image-preview-contents">
    <div class="image-preview">
        <div class="fader" style="position: absolute;top: 0;display: flex;flex-direction:column;color:white;background-color:#00000088;display:flex;align-items:center;justify-content:center;height:100%;width:100%;flex-scrollDirection:column;">
            <div id="percentage" style="padding:5px 5px;">0%</div><progress max="100" value="0"></progress>
        </div>
    </div>
    <textarea class="form-control mb-3" name="postImageDescription" id="postImageDescription" placeholder="Describe this image for people using screen readers."></textarea>
    <div class="image-preview-controls">
        <div class="image-control image-clear" title="Clear image"><i class="fas fa-times"></i></div>
        <div class="image-control image-move" title="Move image" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></div>
    </div>
</script>

<script>
    //okay so the below is the code that configures the quill.js text editor to work how we want it to vis-a-vis text formatting and using inline image and
    //link preview elements, both of which i'm referring to as "embeds" bc i can't think of a better name. "inlines"?

    //within-editor embeds utility functions:
    function updateSubmitButtonState(postForm) {
        var button = postForm.find('.create-comment, #postSubmit');
        if (postForm.find('.still-loading').length == 0) {
            var button = postForm.find('.create-comment, #postSubmit');
            button.attr('disabled', false);
            if (button.hasClass('create-comment')) {
                button.html("Reply");
            } else if (button.attr('id') == "postSubmit") {
                button.html('Send <i class="fas fa-chevron-right"></i>');
            }
        } else {
            button.attr('disabled', true);
            button.html("<i class='fas fa-spinner fa-spin'></i> Uploading");
        }
    }

    //attached directly to the onclick of the x in the embeds when a new one is created (bc of user action or rearrangement). this click event is also artificially triggered when an embed has an error
    function clearEmbed(e) {
        var m = $(this).parent().parent();
        if (m[0].request && m[0].request.readyState != 4) { //if the request is still in progress
            m[0].request.abort();
        }
        var postform = m.closest('.new-comment-form, .contentForm');
        m.remove();
        updateSubmitButtonState(postform);
        createImageGroups(m.closest('.ql-editor'));
    }

    var newEmbedId = 0; //this increments every time an embed is added in an editor anywhere and before that is used to create their ids so they can all be uniquely identified
    //in callbacks that affect embeds, they should be selected by their ids that are formed from this instead of using the existing node variable, bc the re-arranger may have replaced the original element
    //actually i'm not completely sure if that's necessary, but anyway it's easy, just do var $("#embed" + id); (id is declared in the create function where the relevant callbacks are also created)

    //register embed types!
    let BlockEmbed = Quill.import('blots/block/embed');
    class LinkPreview extends BlockEmbed {

        //this is called when the quill api is used to create an embed with type 'LinkPreview' (which is where you pass in the url)
        static create(url) {
            //taken from https://stackoverflow.com/questions/19377262/regex-for-youtube-url
            var youtubeUrlFindingRegex = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/
            //taken from https://github.com/regexhq/vimeo-regex/blob/master/index.js
            var vimeoUrlFindingRegex = /^(http|https)?:\/\/(www\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|)(\d+)(?:|\/\?)$/
            var isVideo = (youtubeUrlFindingRegex.test(url) || vimeoUrlFindingRegex.test(url));
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            node.setAttribute('linkUrl', url);
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('data-url', url);
            node.setAttribute('contenteditable', false);
            node.innerHTML = $("#new-post-link-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass('still-loading');
            n.addClass('slidable-embed');
            n.find('.link-preview-image').on('error', function(e) {
                $(this).replaceWith('<div class="link-preview-image" style="font-size:50px;text-align:center;"><i class="fas fa-link"></i></div>');
            })
            node.request = $.post("/api/newpostform/linkpreviewdata", { url: url }, function(data, status, jqXHR) {
                var m = $("#embed" + id);
                if (!m.length) { return; }
                m.removeClass('still-loading');
                if (data == "invalid url i guess") {
                    bootbox.alert("Sorry, we couldn't connnect to that url (" + url + ") to obtain a preview :(");
                    endMovement(); //in case this link preview is currently being dragged
                    m.find('.image-clear').click();
                } else {
                    var linkInfo = JSON.parse(data);
                    if (linkInfo.image) {
                        m.find(".link-preview-image").attr('src', linkInfo.image)
                    } else {
                        m.find(".link-preview-image").replaceWith('<div class="link-preview-image" style="font-size:50px;text-align:center;"><i class="fas fa-link"></i></div>');
                    }
                    m.find('.link-preview-title').html(linkInfo.title);
                    m.find('.link-preview-description').html(linkInfo.description);
                    m.find('.link-preview-domain').html(linkInfo.domain + (isVideo ? ' (will open as embed)' : ''));
                    updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                }
            })
            node.request.fail(function(jqXHR, textStatus, error) {
                var m = $("#embed" + id);
                if (!m.length) { return; }
                m.removeClass('still-loading');
                bootbox.alert("Sorry, we couldn't connect to that url (" + url + ") to obtain a preview :(");
                endMovement(); //in case this link preview is currently being dragged
                m.find('.image-clear').click();
                if (error != "abort") {
                    $.post("/admin/reporterror", { errorstring: "error creating link preview for url " + url + ":\n" + error });
                }
            })

            n.find('.image-clear').click(clearEmbed);
            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        //quill calls this function to find out what value it should put for this embed in the object it returns when you call getContents() on it
        //(or what value to pass to create() if it has to recreate this object bc of an undo)
        static value(node) {
            return node.getAttribute('data-url');
        }

        //quill calls this function to find out what attributes it should put for this embed in the object it returns when you call getContents() on it
        static formats(node) {
            var n = $(node);
            if (n.hasClass('still-loading') || n.hasClass('onthemove') || n.hasClass('embedspacer')) {
                return {};
            }
            return { title: n.find('.link-preview-title').html(), description: n.find('.link-preview-description').html(), domain: n.find('.link-preview-domain').html().replace(' (will open as embed)', ''), image: n.find('.link-preview-image').attr('src') }
        }
    }

    LinkPreview.blotName = 'LinkPreview';
    LinkPreview.tagName = 'a';
    LinkPreview.className = 'link-preview-container';
    Quill.register(LinkPreview);

    var files = {}; //each file object is stored in this object under the container's id so that if a user deletes an image embed and then undoes that action, quill can find the file in here and reconstitute the embed from it.
    class PostImage extends BlockEmbed {

        //this is called when the quill api is used to create an embed with type 'PostImage' (which is where you pass in the file)
        static create(file) {
            if (file.type != "image/jpeg" && file.type != "image/png" && file.type != "image/gif") {
                bootbox.alert("Sorry, but this appears to be an unsupported file type! We only take JPG, PNG, and GIF images at the moment");
                return null;
            } else if (!(((file.type === "image/jpeg" || file.type === "image/png") && file.size < 10485760) || (file.type === "image/gif" && file.size < 5242880))) {
                bootbox.alert("Sorry, but this file appears to be too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                return null;
            }
            let node = super.create();
            node.setAttribute('id', 'embed' + newEmbedId);
            files[node.getAttribute('id')] = file; //store the file in case quill needs to re-create the embed with it bc of an undo action (or redo i guess?)
            var id = newEmbedId;
            newEmbedId++;
            node.setAttribute('contenteditable', false);
            node.setAttribute('image-url', 'loading...')
            node.innerHTML = $("#new-post-image-preview-contents")[0].innerHTML;
            var n = $(node);
            n.addClass("still-loading");
            n.addClass('slidable-embed');
            //create filereader that will obtain us the preview
            var fr = new FileReader();
            fr.onload = function(e) {
                var m = $("#embed" + id)
                if (m) { //our preview window might have already been eliminated by a cancel operation
                    m.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
                }
            }
            fr.fileType = file.type;
            fr.readAsDataURL(file);

            //make the image-uploading ajax request
            var fd = new FormData();
            fd.append('image', file);

            node.request = $.ajax({
                xhr: function() {
                    var uploader = new XMLHttpRequest();
                    uploader.upload.addEventListener("progress", function(e) {
                        var percentage = Math.round(e.loaded / e.total * 100);
                        var m = $("#embed" + id)
                        m.find('progress').attr('value', percentage);
                        m.find("#percentage").html(percentage == 100 ? percentage + '%!!!' : percentage + '%')
                    });
                    return uploader;
                },
                url: '/api/image/v2',
                type: 'POST',
                data: fd,
                processData: false,
                contentType: false,
                error: function(jqxhr, status, error) {
                    var m = $("#embed" + id)
                    m.find('progress').attr('value', 0);
                    m.find("#percentage").html("Upload error :( Hit the X and try again?");
                    console.log("image upload error: " + error);
                    m.removeClass('still-loading');
                    updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                    if (error != "abort") {
                        $.post("/admin/reporterror", { errorstring: "error uploading image:\n" + error });
                    }
                },
                success: function(data, status, jqXHR) {
                    var m = $("#embed" + id)
                    m.removeClass("still-loading");
                    var serverResponse = JSON.parse(data);
                    //check for file errors. shouldn't ever happen bc of the check at the beginning of this function, but we need server-side checking still anyway, so...
                    if (serverResponse.error) {
                        if (serverResponse.error == "filesize") {
                            bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
                        } else if (serverResponse.error == "filetype") {
                            bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
                        }
                        endMovement(); //in case this link preview is currently being dragged
                        m.find('.image-clear').click();
                    } else {
                        if (serverResponse.thumbnail) {
                            m.find('.image-preview').css('background-image', "url(" + serverResponse.thumbnail + ")"); //we want the server-created thumbnail bc it will be exif-rotated and transparency-removed as seen fit
                        }
                        m.find('.fader').remove();
                        m.attr('image-url', serverResponse.url);
                        updateSubmitButtonState(m.closest('.new-comment-form, .contentForm'));
                    }
                }
            });

            n.find('.image-clear').click(clearEmbed);

            n.find('.image-move').on('mousedown', mousedownOnHandle);
            n.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });

            return node;
        }

        //quill calls this function to find out what value it should put for this embed in the object it returns when you call getContents() on it (although we don't use this there)
        //or what value to pass to create() if it has to recreate this object bc of an undo, which we can use
        static value(node) {
            return files[node.getAttribute('id')];
        }

        //quill calls this function to find out what attributes it should put for this embed in the object it returns when you call getContents() on it
        static formats(node) {
            return { description: $(node).find('#postImageDescription').val(), imageURL: node.getAttribute('image-url') };
        }
    }
    PostImage.blotName = 'PostImage';
    PostImage.tagName = 'div';
    PostImage.className = 'image-preview-container';
    Quill.register(PostImage);

    //element is the div that will now become the container for the quill editor and will have the class ql-container. not to be confused with the ql-editor div inside.
    function attachQuill(element, placeholder, embedsForbidden) {
        var quill = new Quill(element, {
            modules: {
                toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
                keyboard: {
                    bindings: {
                        //if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                        blqtBksp: {
                            key: 'backspace',
                            collapsed: true,
                            format: ['blockquote'],
                            offset: 0,
                            handler: function(range, context) {
                                this.quill.format('blockquote', false);
                            }
                        },
                        //also, if the user hits backspace with the cursor on a newline after an embed, delete the newline instead of the embed before it
                        embedBksp: {
                            key: 'backspace',
                            collapsed: true,
                            offset: 0,
                            handler: function(range, context) {
                                if (this.quill.getText(range.index, 1) == "\n") {
                                    var before = this.quill.getContents(range.index - 1, 1);
                                    if (before.ops.length && before.ops[0].insert && (before.ops[0].insert.LinkPreview || before.ops[0].insert.PostImage)) {
                                        this.quill.deleteText(range.index, 1);
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                    }
                }
            },
            placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
            theme: 'bubble'
        });
        //prevent image html elements from being copied and pasted in (raw image files are fine and are detected by the onpaste listener below, this just blocks "hotlinked" external images)
        quill.clipboard.addMatcher("img", function(node, delta) {
            return { ops: [] };
        });
        //remove pasted formatting that we don't support. copying and pasting embeds has been erratic for me so this just blocks it, although that probably deserves a second look someday
        quill.clipboard.addMatcher("*", function(node, delta) {
            for (var i = 0; i < delta.ops.length; i++) {
                if (typeof delta.ops[i].insert != "string") { //if it's not a string, it is an embed
                    delta.ops[i].insert = "";
                }
                for (const key in delta.ops[i].attributes) {
                    if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                        delete delta.ops[i].attributes[key];
                    }
                }
            }
            return delta;
        })
        //save the most recent cursor position when the editor loses focus for emoji picker placement. 
        quill.on('selection-change', function(range, oldRange, source) {
            if (!range) {
                element.lastCursorPos = oldRange.index;
            }
        })
        element.insertEmojiAtCursor = function(emojiString) {
            var range = undefined;
            if (range = quill.getSelection()) { //if editor has focus
                if (range.length > 0) { //if there is some text selected
                    quill.deleteText(range.index, range.length);
                }
                quill.insertText(range.index, emojiString)
            } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
                quill.insertText(element.lastCursorPos, emojiString)
            } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
                quill.insertText(0, emojiString)
                quill.focus()
                quill.setSelection(emojiString.length, 0)
            }
        }
        element.hasContent = function() {
            //if there is some text the first will be true; if there are > 0 embeds, the second will be true
            return (quill.getText().trim().length > 0 || quill.getLength() > quill.getText().length);
        }
        //when embeds are forbidden in community pages and whatever a simple selector is used to get the html contents instead of this function
        element.getContents = function() {
            if (element.imagesAdded() > 0 || element.linkPreviewsAdded() > 0) {
                var elements = $(element).children('.ql-editor').children();
                var textWEmbedsArray = [];
                elements.each(function(i, n) {
                    var n = $(n);
                    if (n.hasClass('still-loading') || n.hasClass('onthemove') || n.hasClass('embedspacer') || n.attr('image-url') == "loading...") {
                        return;
                    }
                    if (n.hasClass('link-preview-container')) {
                        textWEmbedsArray.push({ type: "link-preview", linkUrl: n.attr('linkUrl') });
                    } else if (n.hasClass('image-preview-container')) {
                        var prevE = textWEmbedsArray[textWEmbedsArray.length - 1];
                        if (prevE && typeof prevE != "string" && prevE.type == "image(s)") {
                            prevE.imageDescriptions.push(n.find('#postImageDescription').val());
                            prevE.images.push(n.attr('image-url'));
                        } else {
                            textWEmbedsArray.push({ type: "image(s)", imageDescriptions: [n.find('#postImageDescription').val()], images: [n.attr('image-url')] })
                        }
                    } else {
                        textWEmbedsArray.push(n[0].outerHTML);
                    }
                })
                return textWEmbedsArray;
            } else {
                return $(element).children('.ql-editor').html();
            }
        }

        //the following code deals with embeds and is not used when embeds are forbidden, which is currently on community rules and descriptions pages.
        if (!embedsForbidden) {
            //prevent there from ever being embeds at the end of the content with no new lines after to type text on
            quill.on('text-change', function(range, oldRange, source) {
                if (quill.getText() === "") {
                    quill.insertText(quill.getLength(), "\n");
                }
            })
            //addImage and addLinkPreview functions! embeds are added at the bottom of the editor unless the cursor is on a blank line with text somewhere below it (my heuristic for "was intentionally placed there")
            element.addLinkPreview = function(url) {
                var sel = quill.getSelection(true);
                var range = sel.index;
                if (sel.length == 0 && quill.getText(range, 1) == "\n" && quill.getText(range + 1, 1) != "") {
                    quill.deleteText(range, 1);
                    var addEmbedAt = range;
                } else {
                    var addEmbedAt = quill.getLength();
                }
                quill.insertEmbed(addEmbedAt, 'LinkPreview', url, Quill.sources.USER);
                updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
            }

            element.addImage = function(file) {
                var sel = quill.getSelection(true);
                var range = sel.index;
                if (sel.length == 0 && quill.getText(range, 1) == "\n" && quill.getText(range + 1, 1) != "") {
                    quill.deleteText(range, 1);
                    var addEmbedAt = range;
                } else {
                    var addEmbedAt = quill.getLength();
                }
                quill.insertEmbed(addEmbedAt, 'PostImage', file, Quill.sources.USER);
                updateSubmitButtonState($(element).closest('.contentForm, .new-comment-form'));
                createImageGroups($(element).children('.ql-editor'));
            }

            element.imagesAdded = function() {
                return $(element).children('.ql-editor').children('.image-preview-container').length;
            }
            element.linkPreviewsAdded = function() {
                return $(element).children('.ql-editor').children('.link-preview-container').length;
            }

            //create a blank line when someone clicks on the space below an embed if it's the last thing in the editor
            element.onclick = function(e) {
                console.log(e.target);
                var et = $(e.target);
                if (et.hasClass('ql-editor')) {
                    var c = et.children();
                    var firstChild = c.first();
                    var lastChild = c.last();
                    if (firstChild.hasClass('slidable-embed') && e.clientY < getTop(firstChild)) {
                        quill.insertText(0,'\n');
                        quill.setSelection(0);
                    } else if (lastChild.hasClass('slidable-embed') && e.clientY > getTop(lastChild) + lastChild.outerHeight(false)) {
                        quill.insertText(quill.getLength(), '\n');
                        quill.setSelection(quill.getLength());
                    } else {
                        var prev = undefined;
                        var lineAdded = false;
                        et.children().each(function(i, child) {
                            if (!lineAdded) {
                                child = $(child);
                                if (prev) {
                                    if (child.hasClass('slidable-embed') && prev.hasClass('slidable-embed')) {
                                        if (e.clientY < getTop(child) && e.clientY > getTop(prev) + prev.outerHeight(false)) {
                                            var newLine = $('<p></p>')
                                            prev.after(newLine);
                                            var sel = window.getSelection();
                                            var range = document.createRange();
                                            range.setStart(newLine[0],0);
                                            range.collapse(true);
                                            sel.removeAllRanges();
                                            sel.addRange(range);
                                            lineAdded = true;
                                            createImageGroups(et);
                                        }
                                    }
                                }
                                prev = child;
                            }
                        })
                    }
                }
            }
            //listen for and use pasted image data
            element.onpaste = function(e) {
                // event.originalEvent.clipboard for newer chrome versions
                var items = (event.clipboardData || event.originalEvent.clipboardData).items;
                for (var i = 0; i < items.length; i++) {
                    if (element.imagesAdded() > 3) {
                        bootbox.alert("sorry, we only take 4 images at once atm");
                        break;
                    } else {
                        if (items[i].type.indexOf("image") === 0) {
                            element.addImage(items[i].getAsFile());
                            e.preventDefault();
                        }
                    }
                }
            }
            //listen for and use dragged-and-dropped images
            element.ondrop = function(ev) {
                ev.preventDefault();
                $(".post-controls").css('display', 'flex'); //just in case the user hasn't previously clicked in the text area
                if (ev.dataTransfer.items) {
                    for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                        if (element.imagesAdded() > 3) {
                            bootbox.alert("sorry, we only take 4 images at once atm");
                            break;
                        } else if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                            element.addImage(ev.dataTransfer.items[i].getAsFile());
                        }
                    }
                } else {
                    for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                        if (element.imagesAdded() > 3) {
                            bootbox.alert("sorry, we only take 4 images at once atm");
                            break;
                        } else if (ev.dataTransfer.files[i].type.indexOf("image") === 0) {
                            element.addImage(ev.dataTransfer.files[i]);
                        }
                    }
                }
                removeBodyFader(ev);
            }
            if (!dragFaderActivated) {
                $(function() {
                    //this stuff is for to the drag-and-drop handling code for the quill editor above
                    //this activates the fader that dims non-drag-and-drop elements (has a z-index 1 lower than the editor areas)
                    document.body.ondragover = function(e) {
                        e.preventDefault();
                        var dt = e.dataTransfer;
                        //if statement so it won't react if just some text or image from the page is being dragged around
                        if (dt.types && (dt.types.indexOf ? dt.types.indexOf('Files') != -1 : dt.types.contains('Files'))) {
                            if (!faded) {
                                $('body').append('<div id="bodyFader"></div>');
                                $("#bodyFader").fadeIn(100);
                                faded = true;
                            }
                        }
                    }

                    //neutralize a drag-and-drop if it doesn't hit a specific text entry area - assume they just missed
                    document.body.ondragend = removeBodyFader;
                    document.body.ondrop = removeBodyFader
                    //some byzantine logic required to detect when the dragged thing leaves our window entirely:
                    window.ondragenter = function(e) {
                        e.preventDefault();
                        dragcounter++;
                    }
                    window.ondragleave = function(e) {
                        dragcounter--;
                        if (dragcounter < 1) {
                            removeBodyFader(e);
                        }
                    }
                })
                dragFaderActivated = true;
            }
        }
    }


    //incremented and decremented and reset by drag event listeners to keep track of whether the dragged thing is still in our window or not
    var dragcounter = 0;

    var faded = false;
    dragFaderActivated = false;

    function removeBodyFader(e) {
        e.preventDefault();
        $("#bodyFader").fadeOut(100, function() {
            $("#bodyFader").remove();
            dragcounter = 0;
            faded = false;
        });
    }

    //scripts for rearranging the embeds within the text editor

    //these two event listener functions are initially attached to the embeds' movement handles,when they're created, above

    function mousedownOnHandle(mouseDownEvent) {
        mouseDownEvent.preventDefault();
        var selectedEmbed = $(this).parent().parent();

        //turms selectedEmbed into a spacer element. floatyEmbed is going to contain the embed now instead.
        var floatyEmbed = prepareEmbedForMoving(selectedEmbed);

        //this is the distance from the top of the embed to the mouse at the moment of mousedown, when the mouse moves this offset is maintained which moves the embed
        floatyEmbed[0].pointerOffset = mouseDownEvent.originalEvent.clientY - getTop(floatyEmbed);

        prevPointerY = mouseDownEvent.originalEvent.clientY;

        $(document).mousemove(function(e) {
            e.preventDefault();
            moveEmbed(e.originalEvent.clientY, floatyEmbed, selectedEmbed);
            return false;
        });

        $(document).on('mouseup', function(e) {
            endMovement();
            $(document).off('mousemove');
            $(document).off('mouseup');
        });
    }

    var touchinprogress = false;

    function touchStartOnHandle(e) {
        if (e.cancelable) {
            e.preventDefault();
        }

        if (touchinprogress) {
            return; //don't want to try to move two embeds at once
        }
        touchinprogress = true;

        var selectedEmbed = $(this).parent().parent();
        var floatyEmbed = prepareEmbedForMoving(selectedEmbed);
        floatyEmbed[0].pointerOffset = e.changedTouches[0].clientY - getTop(floatyEmbed);
        prevPointerY = e.changedTouches[0].clientY;

        //function to be passed to the touchmove handler and then later removed from it
        function touchmoveevent(event) {
            //this should always be true, if it's not preventDefault raises an error instead of preventing page scrolling and we have Problems
            if (event.cancelable) {
                event.preventDefault();
            }
            moveEmbed(event.changedTouches[0].clientY, floatyEmbed, selectedEmbed);
        }

        this.addEventListener("touchmove", touchmoveevent, { passive: false });

        this.addEventListener('touchend', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            endMovement();
        });

        this.addEventListener('touchcancel', function(e) {
            touchinprogress = false;
            this.removeEventListener('touchmove', touchmoveevent);
            endMovement();
        });
    }

    //gets the position to the element's top relative to the top of the screen, which is the same distance that the css "top" property sets when position:fixed.
    function getTop(e) {
        return e.offset().top - $(window).scrollTop();
    }

    //called by the mousedown or touchstart event listener when movement is initiated
    //this functions creates and returns a new, floaty version of the element you pass in and turns the original into an empty "spacer"
    function prepareEmbedForMoving(selectedEmbed) {

        var floatingVersion = selectedEmbed.clone(false);
        floatingVersion.find('.image-move')[0].addEventListener('touchstart', touchStartOnHandle, { passive: false });
        floatingVersion.find('.image-move').on('mousedown', mousedownOnHandle);
        floatingVersion.find('.image-clear').click(clearEmbed);

        var groupClasses = 'ipc-group ipc-group-top ipc-group-bottom';
        selectedEmbed.removeClass(groupClasses);
        var above = selectedEmbed.prev('.image-preview-container');
        while (above.length) {
            above.removeClass(groupClasses);
            above = above.prev('.image-preview-container');
        }
        var below = selectedEmbed.next('.image-preview-container');
        while (below.length) {
            below.removeClass(groupClasses);
            below = below.next('.image-preview-container');
        }

        var spacer = selectedEmbed;

        spacer.addClass("embedspacer");
        spacer.attr('id', '');

        floatingVersion.css("width", spacer.outerWidth(true) + "px");
        floatingVersion.css("left", spacer.offset().left + "px");
        floatingVersion.css("top", getTop(spacer) + "px");

        spacer.closest('.ql-container').append(floatingVersion);

        //these can be put in the css file under .onthemove if that's preferred. I guess I would rather have them here
        floatingVersion.css("position", "fixed");
        floatingVersion.css("z-index", 2147483647); // over 9000
        floatingVersion.css("background-color", "white");

        floatingVersion.addClass("onthemove");

        spacer.css("border", "dashed")
        spacer.empty();

        floatingVersion[0].scrollPrompterId = setInterval(function() { scrollPrompter(floatingVersion) }, 50);

        lastWindowPos = window.scrollY;
        $(window).on('scroll', function(e) {
            if (window.scrollY > lastWindowPos) {
                moveEmbed(prevPointerY, floatingVersion, spacer, "down")
            } else if (window.scrollY < lastWindowPos) {
                moveEmbed(prevPointerY, floatingVersion, spacer, "up")
            }
            lastWindowPos = window.scrollY;
        })

        return floatingVersion;
    }

    //auto-scrolls when the floating element is less than 100px away from the top or bottom and the top or bottom of the editor is offscreen.
    //called through setInterval, which is started in prepareEmbedForMoving, and then canceled in endMovement
    function scrollPrompter(floatingEmbed) {
        var t = floatingEmbed.offset().top;
        var h = floatingEmbed.outerHeight();
        var b = t + h;
        var pt = floatingEmbed.parent().offset().top;
        var pb = pt + floatingEmbed.parent().outerHeight();
        var w = $(window);
        var wst = w.scrollTop();
        var wh = w.height();
        if (t < wst + 100 && pt < wst + 50) {
            w.scrollTop(wst - 10);
        } else if (b > wh - 100 && pb > (wst + wh)) {
            w.scrollTop(wst + 10);
        }
    }

    //this function is called when the user moves either their mouse or finger to reposition the embed or the screen scrolls in a scrollDirection
    function moveEmbed(pointerY, floatingEmbed, spacer, scrollDirection) {
        var deltaY = pointerY - prevPointerY;
        prevPointerY = pointerY;
        //move the floaty element:
        var floatingEmbedtop = getTop(floatingEmbed);
        var spacertop = getTop(spacer);
        var floatingEmbedh = floatingEmbed.outerHeight(true);
        //new y pos is the pointer's y less the original offset unless that's less than the parent's top bound or more than (the parent's bottom bound - the height of the element)
        var newYPos = Math.min(Math.max(pointerY - floatingEmbed[0].pointerOffset, getTop(spacer.parent())), getTop(spacer.parent()) + (spacer.parent().outerHeight(true) - spacer.outerHeight(true))); //beauty
        floatingEmbed.css("top", newYPos + "px");

        //move the spacer (maybe):

        //if moving down, we move the spacer below the element below the floating element if the floating element's bottom edge has passed over the middle of that element or is less than 70px away from that element's bottom edge, whichever comes last
        if (scrollDirection == "down" || deltaY > 0) { //moving down
            var elementBelow = spacer.next();
            while (elementBelow.length && elementBelow.next().length && (floatingEmbedtop + floatingEmbedh) > (getTop(elementBelow) + elementBelow.outerHeight(true))) {
                elementBelow = elementBelow.next();
            }
            if (elementBelow.length) {
                var ebt = getTop(elementBelow);
                var line = Math.max(ebt + (0.5 * elementBelow.outerHeight(true)), ebt + elementBelow.outerHeight(true) - 70);
                if ((floatingEmbedtop + floatingEmbedh) > line) {
                    spacer.insertAfter(elementBelow);
                }
            }
            //if moving up, we move the spacer above the element above the floating element if the floating element's top edge has passed over the middle of that element or is less than 70px away from that element's top edge, whichever comes last
        } else if (scrollDirection == "up" || deltaY < 0) { //moving up
            var elementAbove = spacer.prev();
            while (elementAbove.length && elementAbove.prev().length && floatingEmbedtop < getTop(elementAbove)) {
                elementAbove = elementAbove.prev();
            }
            if (elementAbove.length) {
                var line = Math.min(getTop(elementAbove) + (0.5 * elementAbove.outerHeight(true)), getTop(elementAbove) + 70);
                if (floatingEmbedtop < line) {
                    spacer.insertBefore(elementAbove);
                }
            }
        }
    }

    //this function is called when the user lifts their finger from their screen or mouse button and the image can find its spot. it's all called to just
    //generally cancel drag and dropping when an alert has to be displayed about an upload, just in case drag and dropping is going on
    function endMovement() {
        var floatingEmbed = $('.onthemove');
        if (floatingEmbed.length) {
            clearInterval(floatingEmbed[0].scrollPrompterId);
            $(window).off('scroll');
            $('.embedspacer').after($('.onthemove'));
            floatingEmbed.css("position", "").css("border", "").css('width', '').css('left', '').css('top', '').css('height', '').css("z-index", 10); //seems like a good number
            floatingEmbed.removeClass("onthemove");
            var spacer = $('.embedspacer');
            spacer.remove();
            createImageGroups(floatingEmbed.closest('.ql-editor'));
        }
    }

    function createImageGroups(qlEditorElement) {
        var kids = qlEditorElement.children();
        kids.removeClass('ipc-group ipc-group-top ipc-group-bottom'); //reset. this is not very well optimized, the loop below could be added to to just remove specific    classes where necessary
        var containersInARow = 0;
        for (var i = 0; i < kids.length; i++) {
            if ($(kids[i]).hasClass('image-preview-container')) {
                containersInARow++;
                if (containersInARow > 1) {
                    if (containersInARow == 2) {
                        $(kids[i - 1]).addClass('ipc-group ipc-group-top');
                    } else {
                        $(kids[i - 1]).addClass('ipc-group');
                    }
                }
            } else {
                if (containersInARow > 1) {
                    $(kids[i - 1]).addClass('ipc-group ipc-group-bottom');
                }
                containersInARow = 0;
            }
        }
        if (containersInARow > 1) {
            $(kids[kids.length - 1]).addClass('ipc-group ipc-group-bottom');
        } else if (containersInARow == 1) {
            $(kids[kids.length - 1]).removeClass('ipc-group ipc-group-top ipc-group-bottom')
        }
    }
</script>