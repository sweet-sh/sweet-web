<script>
    function attachQuill(element, placeholder) {
    var quill = new Quill(element, {
        modules: {
            toolbar: ['bold', 'italic', { 'list': 'bullet' }, 'link', 'blockquote'],
            keyboard: {
                bindings: {
                    //Addition: if the user hits backspace at the beginning of a blockquote, remove that formatting (quill already does this by default for lists)
                    blqtBksp: {
                        key: 'backspace',
                        collapsed: true,
                        format: ['blockquote'],
                        offset: 0,
                        handler: function(range, context) {
                            this.quill.format('blockquote', false);
                        }
                    }
                }
            }
        },
        placeholder: placeholder ? placeholder : 'Write something, highlight text to format.',
        theme: 'bubble'
    });
    //remove pasted images
    quill.clipboard.addMatcher("img", function(node, delta) {
        return { ops: [] };
    });
    //remove pasted formatting that we don't support
    quill.clipboard.addMatcher("*", function(node, delta) {
        for (var i = 0; i < delta.ops.length; i++) {
            for (const key in delta.ops[i].attributes) {
                if (key != "bold" && key != "italic" && key != "link" && key != "blockquote" && key != "list") {
                    delete delta.ops[i].attributes[key];
                }
            }
        }
        return delta;
    })
    //save the most recent cursor position when the editor loses focus
    quill.on('selection-change', function(range, oldRange, source) {
        if (!range) {
            element.lastCursorPos = oldRange.index;
        }
    })
    element.insertEmojiAtCursor = function(emojiString) {
        var range = undefined;
        if (range = quill.getSelection()) { //if editor has focus
            if (range.length > 0) { //if there is some text selected
                quill.deleteText(range.index, range.length);
            }
            quill.insertText(range.index, emojiString)
        } else if (element.lastCursorPos) { //if editor has had focus and thus an active cursor position previously
            quill.insertText(element.lastCursorPos, emojiString)
        } else { //if the editor has not yet been focused (and so will be empty so just put the emoji at the beginning)
            quill.insertText(0, emojiString)
            quill.focus()
            quill.setSelection(emojiString.length, 0)
        }
    }
    element.hasContent = function() {
        return $(element).text().trim().length !== 0;
    }
    element.specialAddImages = function(imgarray) {
        var fileInput = $(this).closest('.new-comment-form, .contentForm').find(".file-input");
        fileInput[0].pastedFiles = imgarray;
        //we attach that function to the file input object events when necessary. can't do them all at once 'cause they're not loaded all at once
        if (!fileInput[0].changeEventAttached) {
            fileInput.change(fileselected);
            fileInput[0].changeEventAttached = true;
        }
        fileInput.change();
    }
    //listen for and use pasted image data
    element.onpaste = function(e) {
        // event.originalEvent.clipboard for newer chrome versions
        var items = (event.clipboardData || event.originalEvent.clipboardData).items;
        // find pasted image among pasted items
        var imgarray = [];
        for (var i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") === 0) {
                imgarray.push(items[i].getAsFile());
            }
        }
        this.specialAddImages(imgarray)
    }
    //listen for and use dragged-and-dropped images
    element.ondrop = function(ev) {
        ev.preventDefault();
        $(".post-controls").css('display', 'flex'); //just in case the user hasn't previously clicked in the text area
        if (ev.dataTransfer.items) {
            var imgarray = [];
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                if (ev.dataTransfer.items[i].kind === 'file' && ev.dataTransfer.items[i].type.indexOf("image") === 0) {
                    imgarray.push(ev.dataTransfer.items[i].getAsFile());
                }
            }
            this.specialAddImages(imgarray);
        } else {
            this.specialAddImages(ev.dataTransfer.files); //the code in fileselected() will have to make sure they at least have the apparent mime type of supported images
        }
        $("#bodyFader").fadeOut(100,function(){
            $("#bodyFader").remove();
        });
        dragcounter = 0;
    }
}
//incremented and decremented and reset by drag event listeners to keep track of whether the dragged thing is still in our window or not
var dragcounter = 0;

//this is used to keep track of the oldest post currently loaded in the feed; when the infinite scroll script fetches the next page of posts,
//it should start with posts just older than that. it starts out with the current time as a placeholder (obvs we only have posts older than the current time.)
needPostsOlderThan = new Date().getTime();

$(function() {
    //this stuff is all here bc it's relevant to the drag-and-drop handling code for the quill editor above
    //this activates the fader that dims non-drag-and-drop elements (has a z-index 1 lower than the editor areas)
    document.body.ondragover = function(e){
        e.preventDefault();
        var dt = e.dataTransfer;
        //so it won't react if just some text or image from the page is being dragged around
        if (dt.types && (dt.types.indexOf ? dt.types.indexOf('Files') != -1 : dt.types.contains('Files'))){
            if(!document.getElementById("bodyFader")){
                $('body').append('<div id="bodyFader"></div>');
                $("#bodyFader").fadeIn(100);
            }
        }
    }
    function removeBodyFader(e){
        e.preventDefault();
        $("#bodyFader").fadeOut(100,function(){
            $("#bodyFader").remove();
            dragcounter = 0;
        });
    }
    //neutralize a drag-and-drop if it doesn't hit a specific text entry area - assume they just missed
    document.body.ondragend = removeBodyFader;
    document.body.ondrop = removeBodyFader
    //some byzantine logic required to detect when the dragged thing leaves our window entirely:
    window.ondragenter = function(e){
        e.preventDefault();
        dragcounter++;
    }
    window.ondragleave = function(e){
        dragcounter--;
        if(dragcounter<1){
            removeBodyFader(e);
        }
    }
})
</script>