{{!-- cloned in the script below to make the image previews --}}
<div class="newimageform">
  <div class="image-preview"><div class="fader" style="color:white;background-color:#00000088;display:flex;align-items:center;justify-content:center;height:100%;width:100%;flex-direction:column;"><div id="percentage" style="padding:5px 5px;">0%</div><progress max="100" value="0"></progress></div></div>
  <textarea class="form-control mb-3" name="postImageDescription" id="postImageDescription" placeholder="Describe this image for people using screen readers." {{#if sessionFlash.errorImageDescription }}value="{{sessionFlash.errorImageDescription}}" {{/if}}></textarea>
  <div class="image-preview-controls">
    <a href="javascript:void(0)" class="image-control image-clear" title="Clear image"><i class="fas fa-times"></i></a>
    <a href="javascript:void(0)" class="image-control image-move" title="Move image" ondragstart="return false;" ondrop="return false;"><i class="fas fa-arrows-alt"></i></a>
  </div>
</div>

{{> newCommentFormTemplate}}

<script type="text/javascript">

//this is here bc it's called after a post is made, although it's ALSO called when you click on the "new posts available" notice
function restartInfiniteScroll(timestamp){
  if(!timestamp){
    timestamp = new Date().getTime();
  }
  var postsContainer = $('#postsContainer');
    postsContainer.fadeOut(250,function(){
      postsContainer.html("");
      needPostsOlderThan = timestamp;
      postsContainer.infiniteScroll('loadNextPage');
      postsContainer[0].fadedOut = true;
    });
  }

//NEW POST FORM CODE

$(function(){

  var editor = undefined;
  if(editor = document.getElementById('editor')){
    attachQuill(editor)
  }

  $(".ql-editor").focus(function (e) {
    if(e.target.parentElement.id == "editor"){
      $(".post-controls").css('display', 'flex');
    }
  })

  $("#postContentWarningsButton").click(function () {
    $("#postContentWarningsContainer").removeClass("bounce")
    if ($("#postContentWarningsContainer").is(":hidden")) {
        $("#postContentWarningsContainer").slideDown("fast");
    }
    else if ($("#postContentWarningsContainer").is(":visible") && !$("#postContentWarnings").val()) {
        $("#postContentWarningsContainer").slideUp("fast");
    }
    else {
        $("#postContentWarningsContainer").addClass("bounce")
    }
  })
  $("#postPrivacy-private").change(function () {
    if (this.checked) {
      $("label[for='postPrivacy-private']").html("<i class='fas fa-eye-slash'></i> Private");
      $("label[for='postPrivacy-public']").html("<i class='fas fa-eye'></i>");
    }
  });
  $("#postPrivacy-public").change(function () {
    if (this.checked) {
      $("label[for='postPrivacy-public']").html("<i class='fas fa-eye'></i> Public");
      $("label[for='postPrivacy-private']").html("<i class='fas fa-eye-slash'></i>");
    }
  });
  $("#emojiWindowButton").click(function () {
    $("#emojiWindow").slideToggle("fast");
    $("#editor").find(".ql-editor").focus()
  })
  $("#emojiWindow>.add-emoji").click(function () {
    $("#editor")[0].insertEmojiAtCursor(event.target.innerHTML);
  })
})

  //IMAGE UPLOADER CODE

  //the main functions are placed outside of the jQuery $(function(){}) document.onready thing because they need to be globally available to the image pasting + dragging and dropping code, not just the event listeners they're attached to directly below.

  //function called right after the file input changes for the post and comment forms or after an image is pasted into an editor (with image(s) contained in imgarray) bc that triggers the change event artificially
  function fileselected(e) {
    if(this.files.length!=0){
      var fileList = this.files;
    }else{
      var fileList = this.pastedFiles;
    }
    let previewContainer = $(this).parent();
    previewContainer.css('display', 'flex'); //this is where we unhide the preview container if this is a comment image. no need to rehide, it's not obtrusive there while empty (at least to me)
    previewContainer = previewContainer[0];

    for (var i = 0; i < fileList.length; i++) {
      //check to make sure it's a supported file type of the correct size
      if (((fileList[i].type === "image/jpeg" || fileList[i].type === "image/png") && fileList[i].size < 10485760) || (fileList[i].type === "image/gif" && fileList[i].size < 5242880)) {

        if ($(previewContainer).children().length == 5) { //if we already have 4 image previews + the file input, which is also a child of the preview container
          bootbox.alert("We only take four images at once atm, sry");
          break;
        }

        var submitbutton = $(this).closest('.contentForm').find('button[type="submit"]');
        submitbutton.html("<i class='fas fa-spinner fa-spin'></i> Uploading").prop('disabled', true);

        //initialize variables for this image uploady thing
        if (!previewContainer.uploadsStarted) {
          previewContainer.uploadsStarted = 0;
          previewContainer.uploadsCompleted = 0;
          previewContainer.uploadsCancelled = 0;
          previewContainer.uploadedImageUrls = [];
          previewContainer.imageUploadRequests = [];
        }

        //add preview windows
        var newimagecont = $(".newimageform").clone();
        newimagecont.find('.image-move')[0].addEventListener('touchstart', touchstartforimagemove, {
          passive: false
        });
        newimagecont.attr('class', 'newimagecont').attr('uploadnumber', previewContainer.uploadsStarted).appendTo(previewContainer);

        //create filereader that will obtain us the preview
        var fr = new FileReader();
        fr.uploadNumber = previewContainer.uploadsStarted; //lets us find the preview window to give this image to when done
        fr.previewContainer = previewContainer;
        fr.onload = function (e) {
          let bgRecipient = $(this.previewContainer).find('.newimagecont[uploadnumber="' + this.uploadNumber + '"]');
          if (bgRecipient) { //our preview window might have already been eliminated by a cancel operation
            bgRecipient.find('.image-preview')[0].style.backgroundImage = "url(" + e.target.result + ")";
          }
        }
        fr.fileType = fileList[i].type;
        fr.readAsDataURL(fileList[i]);

        //make the image-uploading ajax request
        var fd = new FormData();
        fd.append('image', fileList[i]);

        let imageUploadReq = $.ajax({
          xhr: function(){
            var uploader = new XMLHttpRequest();
            var uploadNumber = previewContainer.uploadsStarted;
            uploader.upload.addEventListener("progress", function(e){
              var thisImagesWindow = $(previewContainer).find('.newimagecont[uploadnumber="' + uploadNumber + '"]');
              var percentage = Math.round(e.loaded / e.total * 100);
              thisImagesWindow.find('progress').attr('value',percentage);
              thisImagesWindow.find("#percentage").html(percentage+'%')
            });
            return uploader;
          },
          url: '/api/image/v2',
          type: 'POST',
          data: fd,
          processData: false,
          contentType: false
        });
        imageUploadReq.uploadNumber = previewContainer.uploadsStarted;
        imageUploadReq.previewContainer = previewContainer;
        imageUploadReq.fail(function(jqXHR, textStatus, errorThrown){
          var thisImagesWindow = $(previewContainer).find('.newimagecont[uploadnumber="' + jqXHR.uploadNumber + '"]');
          thisImagesWindow.find('progress').attr('value',0);
          thisImagesWindow.find("#percentage").html("Upload error :( Hit the X and try again?")
        })
        imageUploadReq.done(function (data, textstatus, jqXHR) {
          //find the corresponding preview window
          var thisImagesWindow = $(jqXHR.previewContainer).find('.newimagecont[uploadnumber="' + jqXHR.uploadNumber + '"]');

          var serverResponse = JSON.parse(data);
          //check for filesize error. shouldn't ever happen bc of the check around this whole function, but we need server-side checking still anyway, so...
          if (serverResponse.error) {
            if(serverResponse.error == "filesize"){
              bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
            }else if(serverResponse.error == "filetype"){
              bootbox.alert("We cannot use this file! Please make sure you are uploading a JPG, PNG, or GIF from this universe.");
            }
            jqXHR.previewContainer.uploadsCancelled++;
            if (jqXHR.previewContainer.uploadsStarted - jqXHR.previewContainer.uploadsCancelled == jqXHR.previewContainer.uploadsCompleted) {
              let submitbutton = thisImagesWindow.closest(".contentForm").find('button[type="submit"]');
              submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
            }
            thisImagesWindow.remove();
          } else {
            //get the temp image from the server, which will be exif-rotated properly, and put it in the preview area when it's loaded
            $.get({
              url:'/api/image/display/temp/'+serverResponse.url,
              dataType: 'binary',
              xhr: function() {
                var downloader = new XMLHttpRequest();
                downloader.responseType = 'blob';
                return downloader;
              },
              success: function(response){
                var reader = new FileReader();
                reader.onload = function(e){
                  thisImagesWindow.find('.image-preview').css('background-image',"url(" + e.target.result + ")");
                  thisImagesWindow.find('.fader').remove();
                }
                reader.readAsDataURL(response);
            }})
            jqXHR.previewContainer.uploadedImageUrls.push(serverResponse.url); //will be at position given by uploadsCompleted
            thisImagesWindow.attr('urlpos', jqXHR.previewContainer.uploadsCompleted++); //so we can figure out which url to remove when that window's delete button is hit
            if (jqXHR.previewContainer.uploadsStarted - jqXHR.previewContainer.uploadsCancelled == jqXHR.previewContainer.uploadsCompleted) {
              let submitbutton = thisImagesWindow.closest(".contentForm").find('button[type="submit"]');
              submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
            }
          }
        });
        previewContainer.imageUploadRequests.push(imageUploadReq); //will be positioned at the preview window's uploadnumber
        ++previewContainer.uploadsStarted;
      } else {
        if (!(fileList[i].type === "image/jpeg" || fileList[i].type === "image/gif" || fileList[i].type === "image/png")) {
          bootbox.alert("You appear to have sent us a file of unsupported type! Atm we only take gifs, jpgs, and pngs");
        } else {
          bootbox.alert("Image too large! The maximum size for GIF images is 5MB and for JPG and PNG images is 10MB.");
        }
      }
    }
    $(previewContainer).children('input').val(''); //we need to reset this so that file selection consistently registers as a 'change' event
  }

$(function(){
  $("body").on('click', '#postImageButton', function (e) {
    let ourFileInputGuy = $(this).closest('.post-controls').siblings('#image-preview-holder').children('.file-input'); //bit sketchy! oh well
    //attach the function to the file input object events when necessary. can't do them all at once 'cause they're not loaded all at once
    if (!ourFileInputGuy[0].changeEventAttached) {
      ourFileInputGuy.change(fileselected);
      ourFileInputGuy[0].changeEventAttached = true;
    }
    ourFileInputGuy.click();
  })

  //function for removing an image from a post or comment
  $("body").on('click', '.image-clear', function (e) {
    let thisPreviewWindow = $(this).parent().parent();
    let previewContainer = thisPreviewWindow.parent()[0];
    let reqid = thisPreviewWindow.attr('uploadnumber');
    let thisReq = previewContainer.imageUploadRequests[reqid];
    if (thisReq.readyState != 4) { //if the upload is still in progress
      thisReq.abort();
      ++previewContainer.uploadsCancelled;
      if (previewContainer.uploadsStarted - previewContainer.uploadsCancelled == previewContainer.uploadsCompleted) {
        var submitbutton = $(this).closest(".contentForm").find('button[type="submit"]');
        submitbutton.html('Send <i class="fas fa-chevron-right"></i>').prop('disabled', false);
      }
    } else {
      let url = previewContainer.uploadedImageUrls[thisPreviewWindow.attr('urlpos')];
      $.post("/cleartempimage", {
        imageURL: url
      });
      previewContainer.uploadedImageUrls[thisPreviewWindow.attr('urlpos')] = ""; //we can't just remove the url without throwing off the numbering for all following ones
    }
    thisPreviewWindow.remove();
  })

  var haveWeSentPost = false;
  //function for very specifically submitting a post, not a comment
  $("#postSubmit").click(function (e) {
    if (haveWeSentPost) {
      return;
    }
    e.preventDefault();
    let editor = $('#editor');
    let postContent = editor.find(".ql-editor").html();
    let pc = $(this).closest('.post-controls').siblings('#image-preview-holder')[0]; //bit sketchy! oh well
    //only do anything if there are no pending uploads and there is some text or image(s) to post
    if ((!pc.uploadsStarted || pc.uploadsCompleted == pc.uploadsStarted - pc.uploadsCancelled) && ($(pc).find('.newimagecont').length != 0 || editor[0].hasContent())) {
      let sortedurls = []; //putting urls in preview-window order, instead of the order in which they were recieved from the server
      let imagedescs = [];
      for (let i = 0; i < $(pc).find('.newimagecont').length; i++) {
        let imageWindow = $($(pc).find('.newimagecont')[i]); // i feel like there's a cleaner way to do this than $($())
        sortedurls.push(pc.uploadedImageUrls[imageWindow.attr('urlpos')]);
        imagedescs.push(imageWindow.find('#postImageDescription').val());
      }
      $(this).attr('disabled');
      $.ajax({
        url: '/createpost',
        type: 'POST',
        data: {
          communityId: $('#postForm').attr("communityId"),
          postPrivacy: ($('#postPrivacy-public').is(':checked') ? 'public' : 'private'),
          postContent: postContent,
          postContentWarnings: $('#postContentWarnings').val(),
          postImageDescription: JSON.stringify(imagedescs),
          postImageURL: JSON.stringify(sortedurls),
        }
      }).done(function (postTimestamp) { //actually this should be a string set to the 1 millisecond later than the new post's timestamp.
        $('#postContentWarnings').val("");
        $("#postContentWarningsContainer").slideUp("fast");
        editor.find(".ql-editor").html("");
        $(pc).children('.newimagecont').remove();
        haveWeSentPost = false;
        restartInfiniteScroll(postTimestamp) //we'll requests posts older than that specific timestamp, so the new post should always be on top, with any even newer posts not shown.
      });
      haveWeSentPost = true;
    } else {
      bootbox.alert("This post appears to be... empty");
    }
  });

  //function for sumbitting a comment and then placing the new comment on the page
  $('body').on('click', '.create-comment', function() {
    let commentButton = $(this);
    let commentForm = commentButton.closest('.new-comment-form');
    let commentType = commentForm.attr('data-comment-type');
    let postID = commentForm.attr('data-post-id');
    let commentID = commentForm.attr('data-comment-id');
    let commentContainer = commentForm.find(".ql-container");
    let commentEditor = commentForm.find('.ql-editor');
    let commentContent = commentEditor.html();
    if (commentType == "primary") {
        commentsContainer = commentButton.closest('.comments').find('.comments-container');
    }
    else if (commentType == "child") {
        commentsContainer = commentButton.closest('.comments-container').find('.comment[data-comment-id='+commentID+']').find('.replies')[0];
    }
    let emojiWindow = commentForm.find('.replyEmojiWindow');

    let pc = commentForm.find('#image-preview-holder')[0];

    var sortedurls = []; //will contain urls in preview-window order, instead of the order in which they were recieved from the server
    var imagedescs = [];

    if(pc.uploadsCompleted){
      if(pc.uploadsCompleted != pc.uploadsStarted-pc.uploadsCancelled){
        bootbox.alert("You have image uploads in progress.");
        return;
      }else{
        for(let i=0; i < $(pc).find('.newimagecont').length; i++){
          let imageWindow = $($(pc).find('.newimagecont')[i]); // i feel like there probably exists a cleaner way to do this than $($())?
          sortedurls.push(pc.uploadedImageUrls[imageWindow.attr('urlpos')]);
          imagedescs.push(imageWindow.find('#postImageDescription').val());
        }
      }
    }

    if (commentContainer[0].hasContent() || sortedurls.length > 0) { // Filter out empty comments
      commentButton.prop('disabled', true);
      $.post("/createcomment/"+postID+"/"+commentID,
      { commentContent: commentContent,
        imageUrls: JSON.stringify(sortedurls),
        imageDescs: JSON.stringify(imagedescs)
      },
      function(data) {
        if (data!='nope'){
          commentEditor.html('');
          var appendedComment = $(data.comment).hide().appendTo(commentsContainer).fadeIn();
          //add the lightbox listener to the newly appended comment images
          var commentimages = appendedComment.find('.post-images a');
          if (commentimages.length > 0) {
            var $images = commentimages;
            var $imagesGrouped = $images.filter('[data-group]');
            var $imagesAlone = $images.not($imagesGrouped);
            var params = {
              // your params
            };

            // Handle standalone images
            $imagesAlone.each(function (index, element) {
              $(element).simpleLightbox(params);
            });

            // Handle grouped imags
            if ($imagesGrouped.length > 0) {
              // Select all groups
              var groupNames = $imagesGrouped.map(function () {
                return $(this).data('group');
              }).get();
              groupNames = $.unique(groupNames);

              // Apply on each group
              $.each(groupNames, function (key, value) {
                $imagesGrouped.filter(function () {
                    return $(this).data('group') == value;
                  })
                  .simpleLightbox(params);
              });
            }
          }

          let counterToChange = commentButton.closest(".post").find(".show-comments").find('.comments-number')[0];
          if(counterToChange.textContent === ""){
            counterToChange.innerHTML = "1";
          } else {
            let newCommentCount = parseInt(counterToChange.textContent)+1;
            counterToChange.innerHTML = counterToChange.innerHTML.replace((newCommentCount-1), newCommentCount);
          }
          // Reset (or DESTROY) comment form
          if (commentType == "primary") {
              commentButton.prop('disabled', false);
              emojiWindow.hide();
              $(pc).children('.newimagecont').remove(); //removes all image preview windows
          }
          else if (commentType == "child") {
              commentForm.remove();
          }
          pc.uploadsStarted = 0;
          pc.uploadsCompleted = 0;
          pc.uploadsCancelled = 0;
          pc.uploadedImageUrls = [];
          pc.imageUploadRequests = [];
        } else {
          let html = '<article class="comment"><div class="alert alert-danger">There has been a problem posting your comment. Sorry! Please copy the comment text, refresh the page, and try again.</div></article>'
          $(html).hide().appendTo(commentsContainer).fadeIn();
          // commentButton.prop('disabled', false); // Probably don't disable the reply button if an error occurs because god knows what else has happened to the form
        }
      });
    }
  })


  //tell the server not to keep any images that are in limbo when the tab they're in is closed/refreshed/whatever.
  //um someone rewrite this so it works with comment images. the server's auto-deleter will take care of temp images once they're more than
  //an hour old anyway though
  /*
  $(window).on("unload", function (e) {
    uploadedImageUrls.forEach(function (url) {
      if (url) {
        $.post("/cleartempimage", {
          imageURL: url
        });
      }
    })
  });
  */
})
  //IMAGE DRAG-AND-DROP ORDERING STUFF

  //PART 1: THE FUNCTIONS THAT DO THE WORK

  //this functions creates and returns a new, floaty version of the element you pass in and turns the original into an empty "spacer"
  function prepareImageForMoving(selectedImage) {
    selectedImage.css("width", selectedImage.width() + "px");
    selectedImage.css("height", selectedImage.height() + "px");

    var imagecont = selectedImage.clone();
    imagecont.find('.image-move')[0].addEventListener('touchstart', touchstartforimagemove, {
      passive: false
    });

    selectedImage.addClass("imagecontspacer");

    var imagecontpos = selectedImage.position();

    selectedImage.prev().after(imagecont);

    imagecont.css("width", imagecont.width() + "px");
    imagecont.css("left", imagecontpos.left + "px");
    imagecont.css("top", imagecontpos.top + "px");

    //these can be put in the css file under .onthemove if that's preferred. I guess I would rather have them here
    imagecont.css("position", "absolute");
    imagecont.css("z-index", 2147483647); // over 9000
    imagecont.css("background-color", "white");

    imagecont.addClass("onthemove");

    selectedImage.css("border", "dashed")
    selectedImage.attr('urlpos','');
    selectedImage.attr('uploadNumber','');
    selectedImage.empty();

    return imagecont;
  }

  //this function is called when the user moves either their mouse or finger to reposition the image.
  function moveimagecont(deltaY, imagecont, spacer) {
    //move the floaty element:
    var imageconttop = imagecont.position().top;
    //new y pos is the old y pos + the mouse's delta-y unless that's less than the parent's top bound or more than the parent's bottom bound - the height of the element
    var newYPos = Math.min(Math.max(imageconttop + deltaY, imagecont.parent().position().top), imagecont.parent().position().top + (imagecont.parent().height() - imagecont.height())); //beauty
    imagecont.css("top", newYPos + "px");

    //move the spacer (maybe):

    //Calculate how many spaces the image has moved (might be more or less than one)
    //This moves the spacer if the image's horizontal center line has gone above the bottom of the image above it or below the top of the image below it
    var spacertop = spacer.position().top;
    var sHeight = imagecont.outerHeight(true);
    var movementOfMiddleLine = imageconttop + 0.5 * sHeight > spacertop ? (imageconttop + 0.5 * sHeight - spacertop) : (imageconttop - 0.5 * sHeight - spacertop);
    var deltaImageIndex = Math.floor(movementOfMiddleLine/sHeight);
    if((movementOfMiddleLine % sHeight > sHeight-5 || movementOfMiddleLine % sHeight < 5) && deltaImageIndex != 0){ //10 pixels deadzone on either side of the imaginary line
      deltaImageIndex -= deltaImageIndex > 0 ? 1 : -1;
    }

    //Move the spacer (in other words, set the future destination of the image) according to deltaImageIndex
    while (deltaImageIndex < 0) {
      if (spacer.prev().prev()) {
        spacer.prev().prev().after(spacer);
      }
      deltaImageIndex += 1;
    }
    while (deltaImageIndex > 0) {
      if (spacer.next()) {
        spacer.next().after(spacer);
      }
      deltaImageIndex -= 1;
    }
  }

  //this function is called when the user lifts their finger from their screen or mouse button and the image can find its spot.
  function movementEnded() {
    $('.imagecontspacer').prev().after($('.onthemove'));
    $('.onthemove').css("position", "unset").css("border", "none").css("z-index", 10); //seems like a good number
    $('.onthemove').removeClass("onthemove");
    $('.imagecontspacer').remove();
  }

  //PART 2: THE EVENT LISTENERS THAT CALL THE FUNCTIONS THAT DO THE WORK
$(function(){
  $('body').on('mousedown', '.image-move', function (e) {
    e.preventDefault();
    var selectedImage = $(this).parent().parent();
    //only do something if there's at least one other image container to switch positions with
    if (selectedImage.parent().children().length <= 2) { //2 = one image container and the file input element.
      return;
    }

    //turms selectedImage into a spacer element. floatyImageCont is going to contain the image now instead.
    var floatyImageCont = prepareImageForMoving(selectedImage);

    $(document).mousemove(function (e) {
      moveimagecont(e.originalEvent.movementY, floatyImageCont, selectedImage);
    });

    $(document).on('mouseup', function (e) {
      movementEnded();
      $(document).off('mousemove');
    });
  });
});

  var touchinprogress = false;

  //this is attached to the preview window's arrow thing when the preview window is created input change event listener
  function touchstartforimagemove(e) {

    if (e.cancelable) {
      e.preventDefault();
    }

    if (touchinprogress) {
      return; //don't want to try to move two images at once, everything would probably need to be rewritten for that
    }
    touchinprogress = true;

    var selectedImage = $(this).parent().parent();
    //only do something if there's at least one other image container to switch positions with
    if (selectedImage.parent().children().length <= 2) { //2 = one image container and the file input element.
      return;
    }

    var floatyImageCont = prepareImageForMoving(selectedImage);

    var previousY = e.changedTouches[0].screenY;

    //function to be passed to the touchmove handler and then later removed from it
    function touchmoveevent(event) {
      //this should always be true, if it's not preventDefault raises an error instead of preventing page scrolling and we have Problems
      if (event.cancelable) {
        event.preventDefault();
      }

      moveimagecont(-1 * (previousY - event.changedTouches[0].screenY), floatyImageCont, selectedImage);
      previousY = event.changedTouches[0].screenY;
    }

    //for some reason jQuery Did Not Want to work with these touch events. Possibly they would like us to be using jQuery Mobile. But, this is pretty simple, we don't need it.
    this.addEventListener("touchmove", touchmoveevent, {
      passive: false
    });

    this.addEventListener('touchend', function (e) {
      touchinprogress = false;
      this.removeEventListener('touchmove', touchmoveevent);
      movementEnded();
    });

    this.addEventListener('touchcancel', function (e) {
      touchinprogress = false;
      this.removeEventListener('touchmove', touchmoveevent);
      movementEnded();
    });
  }
  
</script>
